---
title: e-gineer by Nathan Wallace (@nathanwallace)
---

{% include header.html %}

<div id="homeContent">

  <div id="tweets">
    <div id="tweet-links"><img src="/v2/presentation/bluescope/ajax-loader.gif"></div>
    <p class="more"><a href="https://twitter.com/nathanwallace">Twitter &rarr;</a></p>
  </div>

  <canvas id="brain" width='220' height='500'></canvas>

  <div id="blogs">
    <div id="blog-posts">
      {% for p in site.posts limit:3 %}
      <p class="blog-post"><a href="{{ p.url }}">{{ p.title }}</a>&nbsp;&nbsp;{{ p.date | date: "%e %b %Y" }}</p>
      {% endfor %}
    </div>
    <p class="more"><a href="/v2/blog">Blog &rarr;</a></p>
  </div>

</div>

<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.1/jquery.min.js"></script>

<script type="text/javascript"><!--

// Draw a line from the brain to the input tweet or output blog post.
// The line starts from position (xs, ys) and goes to (xf, yf).
function drawBrainLine (context, xs, ys, xf, yf) {
  var r = 5;
  context.beginPath();
  context.moveTo(xs, ys);
  if ((yf-ys) > r) {
    // heading down to the final position, so it's just a simple line
    // of down, curve and then across
    // down
    context.lineTo(xs, yf-r);
    if (xf < xs) {
      // left
      context.arc(xs-r, yf-r, r, 0, 90*Math.PI/180);
    }
    else {
      // right
      context.arc(xs+r, yf-r, r, 180*Math.PI/180, 90*Math.PI/180, true);
    }
    // across
    context.lineTo(xf, yf);
    context.stroke();
  }
  else {
    // finish point is above start point, so go down, across, up, and
    // then across to the finish
    // down
    context.lineTo(xs, ys+r);
    if (xf < xs) {
      // turn left
      context.arc(xs-r, ys+r, r, 0, 90*Math.PI/180);
      // left
      context.lineTo(xf+3*r, ys+2*r);
      // turn up
      context.arc(xf+3*r, ys+r, r, 90*Math.PI/180, 180*Math.PI/180);
      // up
      context.lineTo(xf+2*r, yf+r);
      // turn left
      context.arc(xf+r, yf+r, r, 0, 270*Math.PI/180, true);
    }
    else {
      // turn right
      context.arc(xs+r, ys+r, r, 180*Math.PI/180, 90*Math.PI/180, true);
      // right
      context.lineTo(xf-3*r, ys+2*r);
      // turn up
      context.arc(xf-3*r, ys+r, r, 90*Math.PI/180, 0, true);
      // up
      context.lineTo(xf-2*r, yf+r);
      // turn right
      context.arc(xf-r, yf+r, r, 180*Math.PI/180, 270*Math.PI/180);
    }
    // finish
    context.lineTo(xf, yf);
    context.stroke();
  }
}

window.onload = function() {
  var canvas = document.getElementById("brain");
  var context = canvas.getContext("2d");
  // Starting position for lines from the brain. Use half points
  // to line up with screen pixel positions.
  startX = 127.5;
  startY = 145.5;
  context.lineWidth = 1;
  context.strokeStyle = '#dddddd';
  // draw the lines from the brain to the blog posts
  tmp = document.getElementsByClassName('blog-post');
  xOffsets = [25, 17, 12]; // x offset of starting points on brain
  for (var i=0; i<tmp.length; i++) {
    drawBrainLine(context, startX+xOffsets[i], startY, canvas.width, tmp[i].offsetTop+tmp[i].offsetParent.offsetTop+12);
  }
}


function relativeTime(time_value) {
  var d = new Date(Date.UTC(time_value.substring(0,4), parseInt(time_value.substring(5,7))-1, time_value.substring(8,10), time_value.substring(11,13), time_value.substring(14,16), time_value.substring(17,19)));
  parsed_date = d.getTime()
  var relative_to = new Date();
  var delta = parseInt((relative_to.getTime() - parsed_date) / 1000);
  if(delta < 120) {
  return '1&nbsp;min&nbsp;ago';
  } else if(delta < (60*60)) {
  return (parseInt(delta / 60)).toString() + '&nbsp;mins&nbsp;ago';
  } else if(delta < (2*60*60)) {
  return '1&nbsp;hour&nbsp;ago';
  } else if(delta < (24*60*60)) {
  return (parseInt(delta / 3600)).toString() + '&nbsp;hours&nbsp;ago';
  } else if(delta < (48*60*60)) {
  return 'Yesterday';
  } else if(delta < (30*24*60*60)) {
  return (parseInt(delta / 86400)).toString() + '&nbsp;days&nbsp;ago';
  } else {
  return 'Long&nbsp;ago';
  }
}

function linkTweet(tweet) {
  // remove any stray line breaks to make regexp easier
  tweet = tweet.replace(/\n/gi,' ');
  // if it's just a bit.ly link, then show as a link
  re_url = /((ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?)/gi;
  re_url_at_end = /(.*\s+)((ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?)$/gi;
  urls = tweet.match(re_url);
  if (urls && (urls.length == 1)) {
    if (tweet.match(re_url_at_end)) {
      return tweet.replace(re_url_at_end, '<a href="$2">$1</a>');
    }
  }
  // otherwise it's a tweet, so linkify it
  regexp = /((ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?)/gi;
  tweet = tweet.replace(regexp,'<a href="$1">$1</a>');
  regexp = /[\@]+([A-Za-z0-9-_]+)/gi;
  tweet = tweet.replace(regexp,"<a href=\"https://twitter.com/$1\">@$1</a>");
  regexp = / [\#]+([A-Za-z0-9-_]+)/gi;
  tweet = tweet.replace(regexp,' <a href="http://search.twitter.com/search?q=&tag=$1&lang=all">#$1</a>');
  return tweet;
}

function twitterItems(items) {
  // Add the twitter items to the page
  max = 5; // We get 8 from twitter, but only show 5 - this prevents gaps for replies etc
  html = '';
  for (i=0;i<max;i++) {
    html += '<p>' + linkTweet(items[i]['text']) + '&nbsp; <span class="timestamp">' + relativeTime(items[i]['created_at']) + '</span></p>';
    html += '<div class="tweet-underline"></div>';
  }
  document.getElementById('tweet-links').innerHTML = html;
  // draw lines from the brain to the tweets
  var canvas = document.getElementById("brain");
  var context = canvas.getContext("2d");
  startX = 127.5;
  startY = 145.5;
  context.lineWidth = 1;
  context.strokeStyle = '#eeeeee';
  // use a gradient for the lines so they fade in from the tweet
  var gradLeft = context.createLinearGradient(startX+10, startY, 0, startY);
  gradLeft.addColorStop(0.6, '#dddddd');
  gradLeft.addColorStop(1, '#eeeeee');
  context.strokeStyle = gradLeft;
  tmp = document.getElementsByClassName('tweet-underline');
  xOffsets = [0, 1, 4, 5, 9];
  for (var i=0; i<tmp.length; i++) {
    drawBrainLine(context, startX+xOffsets[i], startY, 0, tmp[i].offsetTop+tmp[i].offsetParent.offsetTop);
  }

}

// Filters the HTML data from twitter to extract useful data fields (created_at,
// html, text) and send those through to the callback requested when calling
// twitter_get_data
function twitter_receive_data(data) {
  var tweets = new Array();
  var hidden_result = document.createElement("div");
  hidden_result.id = "twitter-hidden-result";
  hidden_result.style.cssText = "display: none";
  $("body").append(hidden_result);
  hidden_result.innerHTML = data.body;
  items = $("#twitter-hidden-result li.tweet").get();
  for (i=0; i<items.length; i++) {
    var datetime = $("time.dt-updated", items[i]).attr("datetime");
    var html = $("p.e-entry-title", items[i]).html();
    $("span.tco-ellipsis", items[i]).replaceWith("");
    $("p.e-entry-title a.link", items[i]).each(function() {
      $(this).replaceWith($(this).attr("href"))
    });
    $("p.e-entry-title a.hashtag", items[i]).each(function() {
      $(this).replaceWith($(this).text())
    });
    $("p.e-entry-title a.profile", items[i]).each(function() {
      $(this).replaceWith($(this).text())
    });
    var text = $("p.e-entry-title", items[i]).html();
    tweets.push({
      created_at: datetime,
      html: html,
      text: text
    });
  }
  _twitter_callback(tweets);
}

// Gets the twitter data for widget_id and triggers the requested
// callback (after filtering the data out through twitter_receive_data)
function twitter_get_data(widget_id, callback) {
  _twitter_callback = callback;
  var c = document.createElement("script");
  c.type = "text/javascript";
  c.src = "https://cdn.syndication.twimg.com/widgets/timelines/" + widget_id + "?&lang=en&callback=twitter_receive_data&suppress_response_codes=true&rnd=" + Math.random();
  $("body").append(c);
}

$(document).ready(function(){
  twitter_get_data('348395096607174657', twitterItems);
});

--></script>

{% include footer.html %}
